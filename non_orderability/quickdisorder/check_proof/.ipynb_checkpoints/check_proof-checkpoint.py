"""
Each nonordering proof tree is stored as a JSON string. The below
example illustrates the general format::

{
    "name":"m003(-3,1)",
    "gens":"a.b.c",
    "rels":["abbcb","ccAcAB","aabcc"],
    "group_args":[1,1,0], 
    "proof":[
        ["a.b","b.a.b.a.b.b.a.a.a.b"],
        ["a.B.c","a.B.c.a.a.c.c"],
        ["a.B.C","C.a.C.a.a.B"]]
 } 

Here "name" is the SnapPy description of the manifold.  The members
"gens" and "rels" give a presentation for its fundamental group, which
was generated by SnapPy's fundamental group method with the specified
"group_args".

The nonordering proof tree itself is encoded in the "proof" item by a
list of its leaves, where each leaf is given by a pair consisting of:

1. The edge labels along the unique path from the root to the leaf,
   separated by periods.

2. The vertex label of the leaf itself, which is a word in the edge
   labels that is 1 in the group.

You can access the stored proofs either by name or at random::

>>> pf = load_proof_by_name('o9_41374(5, 1)')
>>> check_proof(pf, bits_prec=100)
True
>>> other_pf = random_proof()
>>> check_proof(pf, bits_prec=400)  
True
"""

import random, json, os, sys, tarfile
import snappy
import word_problem
import networkx as nx

# The example from the top of this file
sample1 = json.loads(sys.modules[__name__].__doc__.split('\n\n')[1])

def invert_word(word):
    return word.swapcase()[::-1]

def paths_to_root(claims):
    return [c[0] for c in claims]

def build_graph(claims):
    """
    Given a list of claims corresponding to the leaves of a
    nonordering proof tree, build the tree itself as a graph.
    """
    paths = paths_to_root(claims)
    T = nx.DiGraph()
    T.add_node('1')
    leaves = ['1']
    for path in paths:
        vert = '1'
        for g in path:
            new_vert = vert + '.' + g
            T.add_edge(vert, new_vert, label=g)
            vert = new_vert
        leaves.append(vert)
    return T, leaves
    
        
def tree_ok(claims):
    """
    Given a list of claims corresponding to the leaves of a
    nonordering proof tree, checks that the data really defines a
    directed trivalent tree with a unique root vertex.
    """
    T, leaves = build_graph(claims)

    # A branching is a directed forest where every vertex has in-degree
    # a most 1.            
    if not nx.is_branching(T):
        return False

    # Now check that the tree is trivalent.
    degrees = T.degree()
    leaf_count = 0
    for v in T.nodes():
        if v in leaves:
            if degrees[v] != 1:
                return False
            leaf_count += 1
        else:
            if degrees[v] != 3:
                return False
            # Check the outgoing edges of this interior vertex
            # labelled by inverse words.
            w0, w1 = [attr['label'] for attr in T.adj[v].values()]
            if invert_word(w0) != w1:
                return False

    # Make sure there wasn't any redundancy in the path data.
    if leaf_count != len(leaves):
        return False

    # This should be redundant, but might as well check. 
    paths_from_root = nx.single_source_shortest_path(T, '1')
    for v, path in paths_from_root.items():
        for p in path:
            if not v.startswith(p):
                return False
    return True
    
def all_nontrivial_edge_labels(solver, claims):
    edge_labels = set(sum(paths_to_root(claims), []))
    return all(solver.is_nontrivial(e) for e in edge_labels)

def check_claim(solver, claim):
    path_to_root, trivial_word = claim
    is_one = solver.is_trivial(''.join(trivial_word))    
    valid_words = set(path_to_root)
    return set(trivial_word).issubset(valid_words) and is_one

def check_proof(proof, bits_prec=100):
    """
    This is the main function for rigorously verifying that a
    nonordering proof tree is valid.  
    """
    if isinstance(proof, str):
        proof = json.loads(proof)
    M = snappy.Manifold(proof['name'])
    solver = word_problem.WordProblemSolver(M, bits_prec=bits_prec,
                             fundamental_group_args=proof['group_args'])

    # We never actually use these assertions when checking the proof,
    # but it's hard to imagine that we will succeed if they fail.
    assert solver.rho.generators() == proof['gens'].split('.')
    assert solver.rho.relators() == proof['rels']

    claims = proof['proof']
    claims = [(a.split('.'), b.split('.')) for a, b in claims]
    a0 = tree_ok(claims)
    if not a0:
        return False
    a1 = all_nontrivial_edge_labels(solver, claims)
    a2 = all(check_claim(solver, c) for c in claims)
    return a0 and a1 and a2

def check_proof_dodecahedral_qht(proof, bits_prec=100):
    """
    This is the main function for rigorously verifying that a
    nonordering proof tree is valid.  
    """
    if isinstance(proof, str):
        proof = json.loads(proof)
    M = snappy.CubicalOrientableClosedCensus(betti=0)[int(proof['name'])]
    solver = word_problem.WordProblemSolver(M, bits_prec=bits_prec,
                             fundamental_group_args=proof['group_args'])

    # We never actually use these assertions when checking the proof,
    # but it's hard to imagine that we will succeed if they fail.
    assert solver.rho.generators() == proof['gens'].split('.')
    assert solver.rho.relators() == proof['rels']

    claims = proof['proof']
    claims = [(a.split('.'), b.split('.')) for a, b in claims]
    a0 = tree_ok(claims)
    if not a0:
        return False
    a1 = all_nontrivial_edge_labels(solver, claims)
    a2 = all(check_claim(solver, c) for c in claims)
    return a0 and a1 and a2



def check_proof_harder(proof, max_bits=1000):
    """
    Try to check the given proof at higher and higher precisions until
    we succeed or pass max_bits precision.
    """
    bits = 100
    while bits <= 1000:
        try:
            ans = check_proof(proof, bits)
            return ans, bits
        except word_problem.WordProblemError:
            bits = 2*bits
    return False, bits


# --------------- end core code -----------------


# Loading the saved proofs easily
proof_tarball = 'proofs.tar'
if os.path.exists(proof_tarball):
    proof_tarball = tarfile.open(proof_tarball, 'r')
else:
    proof_tarball = None
    
def load_proof_by_name(name):
    if not name.startswith('proofs/'):
        name = 'proofs/' + name
    return json.loads(proof_tarball.extractfile(name).read())

def random_proof():
    proofs = [name for name in proof_tarball.getnames()
              if name.startswith('proofs/') and name.find('/._') == -1]
    return load_proof_by_name(random.choice(proofs))


def proof_sizes():
    """
    Used to gather statistics for the paper
    """
    dir = '/pkgs/tmp/proofs/'
    num_edges = []
    num_leaves = []
    max_edges = 0
    max_leaves = 0
    max_trivial_word = 0    
    
    for f in os.listdir(dir):
        proof = json.loads(open(dir + f).read())
        claims = proof['proof']
        claims = [(a.split('.'), b.split('.')) for a, b in claims]
        T, leaves = build_graph(claims)
        e = T.number_of_edges()
        l = len(leaves)
        num_edges.append(e)
        num_leaves.append(l)
        
        if e > max_edges:
            max_edges = e
            print('edges', e, f)

        if l > max_leaves:
            max_leaves = l
            print('leaves', l, f)

        trivial_words_lengths = [len(c[1]) for c in claims]
        if max(trivial_words_lengths) > max_trivial_word:
            max_trivial_word = max(trivial_words_lengths)
            print('trivial word', max_trivial_word, f)
            
        
    return num_edges, num_leaves, max_trivial_word


if __name__ == '__main__':
    import doctest
    results = doctest.testmod()
    print('check_proof:%s' % (results,))
